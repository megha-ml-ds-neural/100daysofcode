# -*- coding: utf-8 -*-
"""Numpy_2.py

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1D_PuSCTkuz_AIBOA1bfqEQgcQbvBAMvR
"""

import numpy as np

x=np.arange(10)
x

"""***RESHAPING OF ARRAYS***"""

grid=np.arange(1,10).reshape((3,3))

grid

x=np.array([1,2,3])
x.reshape((3,1))

"""***Array concatenation and splitting***

All of the preceding routines worked on single arrays. It’s also possible to combine multiple arrays into one, and to conversely split a single array into multiple arrays. We’ll take a look at those operations here.

Concatenation, or joining of two arrays in NumPy, is primarily accomplished through the routines np.concatenate, np.vstack, and np.hstack. np.concatenate takes a tuple or list of arrays as its first argument, as we can see here:
"""

x=np.array([1,2,3])
y=np.array([4,5,6])

np.concatenate([x,y])

x=np.array([1,2,3])
y=np.array([3,2,1])
np.concatenate([x,y])

z=[99,99,99]
print(np.concatenate([x,y,z]))

"""For 2 dimensional arrays:-"""

grid=np.array([[1,2,3],[4,5,6]])
np.concatenate([grid,grid])

np.concatenate([grid,grid],axis=1)
# Axis 1 is the direction along the rows

np.concatenate([grid,grid],axis=0)
# Axis 0 is the direction along the rows

x = np.array([1, 2, 3])       
 grid = np.array([[9, 8, 7],[6, 5, 4]])
 np.vstack([x,grid])
#   vertically stack the arrays

y = np.array([[99],[99]])       
np.hstack([grid, y])
  # horizontally stack the arrays

"""Splitting of arrays

The opposite of concatenation is splitting, which is implemented by the functions np.split, np.hsplit, and np.vsplit. For each of these, we can pass a list of indices giving the split points:
"""

x=[1,2,3,99,99,3,2,1]
x1,x2,x3=np.split(x,[3,5])
print(x1,x2,x3)

grid=np.arange(16).reshape((4,4))

upper,lower=np.vsplit(grid,[2])
# Split an array into multiple sub-arrays vertically (row-wise).
print(upper)
print(lower)

left,right=np.hsplit(grid,[2])
print(left)
print(right)

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
np.random.seed(0)

def computer_reciprocals(values):
  output=np.empty(len(values))
  for i in range(len(values)):
    output[i]=1.0/values[i]
  return output
values=np.random.randint(1,10,size=5)
computer_reciprocals(values)

big_array = np.random.randint(1, 100, size=1000000)      
# %timeit computer_reciprocals(big_array)

"""For many types of operations, NumPy provides a convenient interface into just this kind of statically typed, compiled routine. This is known as a vectorized operation. You can accomplish this by simply performing an operation on the array, which will then be applied to each element. This vectorized approach is designed to push the loop into the compiled layer that underlies NumPy, leading to much faster execution."""

print(computer_reciprocals(values))
print(1.0/values)

# Commented out IPython magic to ensure Python compatibility.
# %timeit (1.0/big_array)

"""Difference between these two ,u can compare bu using ufunctions:-
1 loop, best of 3: 2.3 s per loop
100 loops, best of 3: 2.46 ms per loop

EXPLORING NUMPY'S FUNCTIONS:-

NumPy’s ufuncs feel very natural to use because they make use of Python’s native arithmetic operators. The standard addition, subtraction, multiplication, and division can all be used
"""

x=np.arange(4)
print("x =",x)
print(" x+5=",x+5)

"""All of these arithmetic operations are simply convenient wrappers around specific functions built into NumPy; for example, the + operator is a wrapper for the add function"""

np.add(3,4)

"""ABSOLUTE VALUE"""

x = np.array([-2, -1, 0, 1, 2])        
abs(x)

np.absolute(x)

"""Trignometric functions

NumPy provides a large number of useful ufuncs, and some of the most useful for the data scientist are the trigonometric functions. We’ll start by defining an array of angles:
"""

theta=np.linspace(0,3)
theta

theta = np.linspace(0, np.pi, 3) 
theta

print(np.sin(theta))
print(np.cos(theta))
print(np.tan(theta))

"""Exponents and logarithms
 Another common type of operation available in a NumPy ufunc are the exponentials
"""

x=[1,2,3]
print(x)
print(np.exp(x))
print(np.power(3,x))

x=[1,2,4,10]
print(x)
print(np.log(x))
print(np.log2(x))
print(np.log10(x))

x = np.arange(5)        
y = np.empty(5)        
np.multiply(x, 10, out=y)        
print(y)

"""For example, calling reduce on the add ufunc returns the sum of all elements in the array"""

m=np.arange(1,5)
np.add.reduce(m)

1+2+3+4

np.multiply.reduce(m)

x = np.arange(1, 6)      
np.multiply.outer(x, x)

"""Summing the values in an array"""

L=np.random.random(100)
sum(L)

"""The syntax is quite similar to that of NumPy’s sum function, and the result is the same in the simplest case"""

np.sum(L)

# Commented out IPython magic to ensure Python compatibility.
big_array = np.random.rand(1000000)      
# %timeit sum(big_array)       
# %timeit np.sum(big_array)













